/*===========================================================================

  avrotest -- receiver

  This class waits for messages from the broker, and converts each message
  into an instance of class Bear using Avro's SpecificDatumReader.

  THIS IS NOT PRODUCTION-QUALITY CODE -- there is poor reuse of objects, and
  the exception handling is lamentable. I've tried to create the simplest,
  reasonably efficient implementation I could.

  Copyright (c)2021 Kevin Boone, GPL v3.0

  https://kevinboone.me/avrotest.html

===========================================================================*/

package net.kevinboone.apacheintegration.avrotest.receiver;
// Model classes generated by tools:
import net.kevinboone.apacheintegration.avrotest.*; 

import java.io.*;
import java.util.*;
import javax.jms.*;
import org.apache.avro.*; 
import org.apache.avro.generic.*; 
import org.apache.avro.specific.*; 
import org.apache.avro.io.*; 
import org.apache.avro.file.*; 

public class Main
  {
  // The location of the schema file depends on the way that the 
  //   apicurio Maven plug-in is configured in pom.xml. In a real 
  //   application it might be better to download it at run-time.
  private final static String SCHEMA_FILE="target/Bear.avsc";
  private final static String PROPS_FILE="../avrotest.props";
  private static DatumReader<Bear> bearDatumReader;
  private static BinaryDecoder decoder = null;

/*===========================================================================

  getMessage

  This method gets a message from the broker as a byte array. It will
  then be converted to an object of class Bear using Avro's 
  SpecificDataReader.

  This is boilerplate JMS code, so I haven't documented it in detail.

  Note that in a real application we'd pool JMS connections, rather than
  creating a new one for each message.

===========================================================================*/
  public static byte[] getMessage (String brokerUri, String brokerUser, 
          String brokerPassword, String brokerQueue)
      throws JMSException
    {
    ConnectionFactory factory =
            new org.apache.qpid.jms.JmsConnectionFactory (brokerUri);
    Connection conn = factory.createConnection (brokerUser, brokerPassword);
    conn.start();

    Session session = conn.createSession (false, Session.AUTO_ACKNOWLEDGE);
    javax.jms.Queue queue = session.createQueue (brokerQueue);
    MessageConsumer consumer = session.createConsumer (queue);
    BytesMessage message = (BytesMessage)consumer.receive();
    // Read the whole message, which we assume is a complete Avro
    //   object, because that's how we created it.
    byte[] bytes = new byte[(int)message.getBodyLength()]; 
    message.readBytes (bytes); 
    consumer.close();
    session.close();
    conn.close();
    return bytes;
    }

/*===========================================================================

  decodeMessage

  This is where the Avro magic happens. This method takes a simple byte
  array, decodes it into an instance of class Bear 

===========================================================================*/
  static Bear decodeMessage (byte[] message)
      throws IOException
    {
    // Note -- we could also do "new SpecificDatumReader<Bear>(schema)"
    //   because the schema was embedded in the Bear class using the avro code
    //   generator
    decoder = DecoderFactory.get().binaryDecoder (message, decoder);
    Bear bear = bearDatumReader.read (null, decoder);
    return bear;
    }

  public static void main (String[] args)
      throws Exception
    {
    Properties props = new Properties();
    props.load (new FileInputStream (PROPS_FILE));
    String brokerUri = props.getProperty ("broker_uri");
    String brokerUser = props.getProperty ("broker_user");
    String brokerPassword = props.getProperty ("broker_password");
    String brokerQueue = props.getProperty ("broker_queue");

    // Load the Avro schema from the JSON file
    Schema schema = new Schema.Parser().parse (new File (SCHEMA_FILE));

    // Create a SpecificDatamWriter for the schema we loaded, that will
    //   deserialize objects of class Bear
    bearDatumReader = new SpecificDatumReader<Bear>(schema);

    // Wait for incoming messages, and decode them. In practice, we'd
    //   probably use some kind of message listener, rather than blocking
    //   like this.
    while (true)
      {
      byte[] message = getMessage (brokerUri, brokerUser, 
           brokerPassword, brokerQueue);
      Bear bear = decodeMessage (message);
      System.out.println (bear);
      }
    }
  }


